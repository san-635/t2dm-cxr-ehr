import torch.nn as nn
import torchvision
import torch

class ResNet(nn.Module):
    def __init__(self, args, device='cpu'):
        super(ResNet, self).__init__()
        self.device = device
        self.vision_backbone = getattr(torchvision.models, args.vision_backbone)(weights = 'IMAGENET1K_V1' if args.pretrained else None)

        # remove final classifier layer from ResNet backbone, in order to use features generated by backbone
        classifiers = ['classifier', 'fc']
        for classifier in classifiers:
            cls_layer = getattr(self.vision_backbone, classifier, None)
            if cls_layer is None:
                continue                                    # if 'classifier' does not exist, continue to 'fc'
            d_visual = cls_layer.in_features
            setattr(self.vision_backbone, classifier, nn.Identity(d_visual))    # set to an identity func., essentially no operation
            break
        
        self.bce_loss = torch.nn.BCELoss(reduction='mean')
        self.feats_dim = d_visual                           # 512
        self.classifier = nn.Linear(d_visual, args.num_classes)

    def forward(self, x, labels=None, n_crops=0, bs=16):
        lossvalue_bce = torch.zeros(1).to(self.device)

        visual_feats = self.vision_backbone(x)
        preds = self.classifier(visual_feats)
        preds = torch.sigmoid(preds)

        if n_crops > 0:
            preds = preds.view(bs, n_crops, -1).mean(1)

        if labels is not None:
            lossvalue_bce = self.bce_loss(preds, labels)

        return preds, lossvalue_bce, visual_feats           # return logits (for encoder pre-training), loss and feature representation (for model training)